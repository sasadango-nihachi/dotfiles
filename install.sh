#!/bin/bash
# ↑ シバン（shebang）: このスクリプトをbashで実行することを指定

#===========================================
# dotfiles install script
#===========================================

set -e
# ↑ エラーが発生したらスクリプトを即座に終了する
#   これがないとエラーが起きても処理が続行されてしまう

DOTFILES_DIR="$HOME/dotfiles"
# ↑ dotfilesの場所を変数に格納
#   $HOME は /home/ユーザー名 に展開される（例: /home/taro）

BACKUP_DIR="$HOME/dotfiles_backup/$(date +%Y%m%d_%H%M%S)"
# ↑ バックアップ先ディレクトリ
#   $(date +%Y%m%d_%H%M%S) はコマンド置換で現在日時を取得
#   例: dotfiles_backup/20260118_143052

LINK_COMMAND_FILE="$DOTFILES_DIR/link_command.txt"
# ↑ リンクコマンドを保存するファイルのパス

#-------------------------------------------
# リンク対象のファイル/ディレクトリ
# 必要に応じて追加・削除してください
#-------------------------------------------
FILES=(
    ".vimrc"
    ".zshrc"
    ".wezterm.lua"
    # ".bashrc"
    ".gitconfig"
    ".gitignore_global"
    ".tmux.conf"
)
# ↑ 配列の定義
#   ホームディレクトリ直下に配置するdotfilesのリスト
#   追加したいファイルがあれば "ファイル名" の形式で追加

CONFIG_DIRS=(
    # "nvim"
    # "starship.toml"
    # "wezterm"
)
# ↑ ~/.config 以下に配置する設定ファイル/ディレクトリ
#   コメントアウト(#)を外すと有効になる

#-------------------------------------------
# 色付き出力用の関数
#-------------------------------------------
info()    { echo -e "\033[34m[INFO]\033[0m $1"; }
# ↑ 情報メッセージを青色で表示
#   echo -e : エスケープシーケンスを解釈する
#   \033[34m : 文字色を青に変更
#   \033[0m  : 文字色をリセット（元に戻す）
#   $1       : 関数の第1引数（渡されたメッセージ）

success() { echo -e "\033[32m[OK]\033[0m $1"; }
# ↑ 成功メッセージを緑色で表示
#   \033[32m : 文字色を緑に変更

warn()    { echo -e "\033[33m[WARN]\033[0m $1"; }
# ↑ 警告メッセージを黄色で表示
#   \033[33m : 文字色を黄に変更

error()   { echo -e "\033[31m[ERROR]\033[0m $1"; }
# ↑ エラーメッセージを赤色で表示
#   \033[31m : 文字色を赤に変更

#-------------------------------------------
# バックアップ作成関数
#-------------------------------------------
backup_if_exists() {
    local target="$1"
    # ↑ local: この関数内でのみ有効な変数を宣言
    #   $1 は関数に渡された第1引数（バックアップ対象のパス）

    if [[ -e "$target" && ! -L "$target" ]]; then
    # ↑ 条件分岐
    #   -e "$target" : ファイルまたはディレクトリが存在するか
    #   -L "$target" : シンボリックリンクかどうか
    #   && : AND条件
    #   ! : NOT（否定）
    #   つまり「存在するが、シンボリックリンクではない」場合

        mkdir -p "$BACKUP_DIR"
        # ↑ バックアップディレクトリを作成
        #   -p : 親ディレクトリも含めて作成、既存なら何もしない

        mv "$target" "$BACKUP_DIR/"
        # ↑ 既存ファイルをバックアップディレクトリに移動

        warn "Backed up: $target -> $BACKUP_DIR/"
        # ↑ バックアップしたことを警告色で表示

    elif [[ -L "$target" ]]; then
    # ↑ シンボリックリンクが既に存在する場合

        rm "$target"
        # ↑ 既存のシンボリックリンクを削除
        #   リンクなのでファイル実体は消えない

        info "Removed existing symlink: $target"
    fi
}

#-------------------------------------------
# シンボリックリンク作成関数
#-------------------------------------------
create_symlink() {
    local src="$1"   # リンク元（dotfilesディレクトリ内のファイル）
    local dest="$2"  # リンク先（ホームディレクトリなど）

    if [[ ! -e "$src" ]]; then
    # ↑ リンク元ファイルが存在しない場合
    #   ! -e : 存在しない

        error "Source not found: $src"
        return 1
        # ↑ return 1 : エラーを示す終了コード1で関数を終了
        #   return 0 は成功を意味する
    fi

    backup_if_exists "$dest"
    # ↑ リンク先に既存ファイルがあればバックアップ

    ln -sf "$src" "$dest"
    # ↑ シンボリックリンクを作成
    #   ln    : リンクを作成するコマンド
    #   -s    : シンボリックリンクを作成（ハードリンクではなく）
    #   -f    : 既存のリンクがあれば強制的に上書き
    #   結果: $dest -> $src へのリンクが作成される

    success "Linked: $dest -> $src"
}

#-------------------------------------------
# リンクコマンドをファイルに保存する関数
#-------------------------------------------
generate_link_commands() {
    local output_file="$1"
    # ↑ 出力先ファイルパスを引数から取得

    # ファイルのヘッダーを書き込み（上書きモード）
    cat > "$output_file" << 'EOF'
#===========================================
# dotfiles link commands
# Generated by install.sh
#===========================================
# このファイルには、dotfilesのシンボリックリンクを
# 作成するためのコマンドが記録されています。
# 手動でリンクを張り直したい場合に参照してください。
#===========================================

EOF
    # ↑ ヒアドキュメント（heredoc）
    #   cat > file << 'EOF' ... EOF で複数行をファイルに書き込む
    #   'EOF' とシングルクォートで囲むと変数展開されない

    # 生成日時を追記
    echo "# Generated: $(date '+%Y-%m-%d %H:%M:%S')" >> "$output_file"
    echo "" >> "$output_file"
    # ↑ >> は追記モード（> は上書き）

    # ホームディレクトリ直下のファイル
    echo "# --- HOME directory files ---" >> "$output_file"
    for file in "${FILES[@]}"; do
        if [[ -e "$DOTFILES_DIR/$file" ]]; then
        # ↑ ファイルが存在する場合のみコマンドを出力
        #   シングルクォートで囲んで $HOME を展開させない
            echo 'ln -sf "$HOME/dotfiles/'"$file"'" "$HOME/'"$file"'"' >> "$output_file"
        fi
    done

    echo "" >> "$output_file"

    # .config 以下のディレクトリ/ファイル
    if [[ ${#CONFIG_DIRS[@]} -gt 0 ]]; then
        echo "# --- .config directory files ---" >> "$output_file"
        echo 'mkdir -p "$HOME/.config"' >> "$output_file"
        for item in "${CONFIG_DIRS[@]}"; do
            if [[ -e "$DOTFILES_DIR/.config/$item" ]]; then
                echo 'ln -sf "$HOME/dotfiles/.config/'"$item"'" "$HOME/.config/'"$item"'"' >> "$output_file"
            fi
        done
    fi

    success "Link commands saved to: $output_file"
}

#-------------------------------------------
# メイン処理関数
#-------------------------------------------
main() {
    echo ""
    echo "=========================================="
    echo "  dotfiles installer"
    echo "=========================================="
    echo ""

    if [[ ! -d "$DOTFILES_DIR" ]]; then
    # ↑ -d : ディレクトリかどうかを判定
    #   dotfilesディレクトリが存在しない場合

        error "dotfiles directory not found: $DOTFILES_DIR"
        exit 1
        # ↑ exit 1 : スクリプト全体をエラー終了
        #   exit 0 は正常終了を意味する
    fi

    info "Installing dotfiles to HOME..."

    for file in "${FILES[@]}"; do
    # ↑ 配列をループ処理
    #   ${FILES[@]} : FILES配列の全要素を展開
    #   "${FILES[@]}" : 各要素を個別の文字列として扱う（スペース対策）

        if [[ -e "$DOTFILES_DIR/$file" ]]; then
        # ↑ dotfilesディレクトリ内にそのファイルが存在するか確認

            create_symlink "$DOTFILES_DIR/$file" "$HOME/$file"
            # ↑ シンボリックリンク作成関数を呼び出し
            #   例: ~/dotfiles/.vimrc -> ~/.vimrc
        else
            warn "Skipped (not found): $DOTFILES_DIR/$file"
            # ↑ ファイルがなければスキップして警告表示
        fi
    done
    # ↑ done : forループの終端

    if [[ ${#CONFIG_DIRS[@]} -gt 0 ]]; then
    # ↑ ${#CONFIG_DIRS[@]} : 配列の要素数を取得
    #   -gt 0 : greater than 0（0より大きい）
    #   つまり CONFIG_DIRS 配列に1つ以上の要素がある場合

        echo ""
        info "Installing configs to ~/.config..."

        mkdir -p "$HOME/.config"
        # ↑ .configディレクトリがなければ作成

        for item in "${CONFIG_DIRS[@]}"; do
            if [[ -e "$DOTFILES_DIR/.config/$item" ]]; then
                create_symlink "$DOTFILES_DIR/.config/$item" "$HOME/.config/$item"
                # ↑ 例: ~/dotfiles/.config/nvim -> ~/.config/nvim
            else
                warn "Skipped (not found): $DOTFILES_DIR/.config/$item"
            fi
        done
    fi

    #-------------------------------------------
    # リンクコマンドファイルの生成
    #-------------------------------------------
    echo ""
    info "Generating link commands file..."
    generate_link_commands "$LINK_COMMAND_FILE"
    # ↑ 実行されたリンクコマンドをファイルに保存
    #   後で手動でリンクを張り直す際の参照用

    echo ""
    echo "=========================================="
    success "Installation complete!"

    if [[ -d "$BACKUP_DIR" ]]; then
    # ↑ バックアップディレクトリが作成されていれば
    #   （何かしらのバックアップが行われた場合）

        info "Backups saved to: $BACKUP_DIR"
    fi
    echo "=========================================="
}

#-------------------------------------------
# スクリプト実行
#-------------------------------------------
main "$@"
# ↑ main関数を呼び出してスクリプトを開始
#   "$@" : スクリプトに渡された全ての引数を展開
#   例: ./install.sh arg1 arg2 → main "arg1" "arg2"
#   現状では引数は使用していないが、将来の拡張に備えて記述